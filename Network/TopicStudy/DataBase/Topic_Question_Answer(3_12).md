### 💬 공통 질문(꼬리 질문)

---

<details>
<summary>1. 데이터베이스에서 JOIN을 수행할 때 내부적으로 어떤 다양한 최적화 기법이나 알고리즘이 사용되나요? </summary>
데이터베이스에서 JOIN 연산을 수행할 때, 최적화 기법은 다음과 같습니다.
<br/>
**Nested Loops Join:** 가장 기본적인 조인 방식으로, 한 테이블의 각 행을 순회하면서 다른 테이블과 비교하여 조건에 맞는 행을 찾습니다.
소규모 데이터셋에서 효율적입니다.
<br/>
**Sort-Merge Join:** 두 테이블을 조인 조건에 맞춰 정렬한 뒤, 순차적으로 비교하며 조인하는 방식입니다.
크기가 큰 데이터셋에 효율적이며, 정렬된 데이터에 최적화되어 있습니다.
<br/>
**Hash Join:** 한 테이블을 기반으로 해시 테이블을 생성하고, 다른 테이블을 순회하며 해시 테이블을 참조해 조인하는 방법입니다. 
대량의 데이터 처리에 유리하며, 메모리 사용량이 많은 편입니다.
<br/>
**Index Join:** 인덱스를 활용해 빠르게 조인할 수 있는 행을 찾는 방식입니다. 
특히, 이미 인덱싱된 컬럼에 대한 조인 시 매우 빠른 성능을 보입니다.
<br/>
</details>

<details> 
<summary>2. B-Tree와 B+Tree 중 어떤 것을 선택할지 결정할 때 고려해야 할 주요 요소는 무엇인가요? </summary>
**접근 시간:** B+Tree는 B-Tree에 비해 더 많은 키를 저장할 수 있으므로, 디스크 I/O 횟수를 줄일 수 있습니다.
<br/>
**데이터 저장 방식:** B-Tree는 각 노드에 키와 데이터를 함께 저장하지만, B+Tree는 리프 노드에만 데이터를 저장합니다.
따라서, 데이터 검색 시 B+Tree가 더 효율적일 수 있습니다.
<br/>
**범위 검색:** B+Tree는 리프 노드들이 링크드 리스트로 연결되어 있어 범위 검색에 유리합니다.
<br/>
**공간 활용도:** B+Tree는 모든 데이터를 리프 노드에 저장하기 때문에 공간 활용도가 더 높을 수 있습니다.
<br/>
</details>

<details> 
<summary>3. 트랜잭션이 긴 실행 시간을 가지고 있을 때, 비관적 락 방식을 사용하면 어떤 문제가 발생될 수 있나요?</summary>
긴 실행 시간을 가진 트랜잭션에서 비관적 락 방식을 사용하면, 다음과 같은 문제들이 발생할 수 있습니다
<br/>
**대기 시간 증가**: 다른 트랜잭션이 락을 기다리는 시간이 길어져 전체 시스템의 처리량이 감소할 수 있습니다.
<br/>
**데드락 발생 위험**: 여러 트랜잭션이 서로의 자원을 기다리는 상태가 될 수 있으며, 이는 시스템이 정지할 수 있는 심각한 상황으로 이어질 수 있습니다.
<br/>
**자원 활용도 저하**: 락이 오래 유지되면서 사용 가능한 자원이 줄어들어, 시스템의 자원 활용도가 떨어질 수 있습니다.
<br/>
</details> 

<details> 
<summary>4. 동시성 문제를 해결하기 위해 Lock말고 다른 방법은 없을까요?</summary>
**낙관적 락(optimistic locking)**: 데이터를 실제로 업데이트하기 전에만 충돌을 확인하는 방식입니다.
충돌 발생 시, 트랜잭션을 재시도합니다.
<br/>
**멀티버전 동시성 제어(MVCC)**: 여러 버전의 데이터를 유지하여, 읽기 작업이 쓰기 작업과 동시에 일어날 수 있도록 합니다.
이는 읽기 작업이 쓰기 작업에 의해 차단되지 않도록 하는 데 효과적입니다.
<br/>
**스냅샷 격리(snapshot isolation)**: 트랜잭션이 시작될 때의 데이터 상태를 기반으로 작업을 수행합니다.
MVCC와 유사한 개념입니다.
<br/>
</details>

<details> 
<summary>5. 인덱스는 왜 B tree를 사용할까요? 다른 자료구조를 사용할 순 없을까요?</summary>
인덱스에 B tree가 자주 사용되는 이유는 다음과 같습니다
<br/>
**효율적인 검색**: B tree는 균형 잡힌 트리 구조를 가지고 있어 검색, 삽입, 삭제 작업이 모두 로그 시간 복잡도를 가집니다.
<br/>
**범위 검색 용이**: B tree는 키 값의 범위 검색이 용이하며, 순차적인 접근이 가능합니다.
<br/>
**디스크 사용 최적화**: B tree는 디스크 블록의 효율적인 사용을 위해 설계되었습니다. 페이지 분할과 병합이 효율적으로 이루어집니다.
<br/>
</details>

<details> 
<summary>6. 그렇다면 조인의 성능이 떨어지는 시점부터 조회 성능을 올리려면 어떻게 해야할까요? (역정규화가 반드시 필요할까요?)</summary>

조인의 성능이 떨어지는 시점부터 조회 성능을 향상시키기 위한 여러 방법이 있습니다.

1. **인덱스 최적화**: 적절한 인덱스 설정은 조인 성능에 큰 영향을 미칠 수 있습니다. 사용되는 컬럼에 대한 인덱스 생성 및 최적화를 통해 성능을 개선할 수 있습니다.

2. **쿼리 최적화**: 쿼리 자체를 최적화하여 불필요한 조인을 제거하거나, 조인의 순서를 변경하는 등의 방법으로 성능을 개선할 수 있습니다.

3. **역정규화**: 데이터의 중복을 허용하고 조인을 줄여 성능을 향상시킬 수 있으나, 데이터의 일관성 유지가 어려워질 수 있습니다. 사용 전에 데이터 무결성과 성능 사이의 균형을 고려해야 합니다.

4. **파티셔닝**: 데이터를 파티셔닝하여 관련 데이터가 같은 파티션에 위치하도록 함으로써, 조회 성능을 향상시킬 수 있습니다.

5. **물리적 설계 변경**: 데이터 저장 방식을 변경하여 디스크 I/O를 줄이는 방법도 있습니다. 예를 들어, SSD를 사용하거나, 데이터를 더 빠른 스토리지에 저장하는 방법이 있습니다.

6. **캐싱**: 자주 사용되는 쿼리 결과를 캐시에 저장하여 빠르게 접근할 수 있도록 하는 것도 하나의 방법입니다.

역정규화는 위와 같은 다른 방법들과 함께 고려될 수 있으며, 상황에 따라 가장 효율적인 방법을 선택하는 것이 중요하다.
</details>
