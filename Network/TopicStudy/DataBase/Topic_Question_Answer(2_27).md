### 💬 공통 질문(꼬리 질문)

---

<details> <summary>1. UNIQUE 키워드와 PRIMARY Key의 차이는 무엇인가요?</summary>
UNIQUE 키와 PRIMARY Key는 둘 다 테이블의 각 행을 고유하게 식별하는 데 사용되지만, 몇 가지 중요한 차이점이 있습니다.
<br/>
PRIMARY Key: 각 테이블은 하나의 PRIMARY Key만 가질 수 있습니다. PRIMARY Key는 NULL 값을 허용하지 않으며, 테이블의 각 행을 고유하게 식별하는 데 사용됩니다.
<br/>
UNIQUE Key: 테이블은 여러 개의 UNIQUE Key를 가질 수 있습니다. UNIQUE Key는 NULL 값을 허용할 수 있습니다(다만, NULL은 고유성을 가집니다. 즉, 하나의 UNIQUE Key 컬럼에는 하나의 NULL 값만 허용됩니다). UNIQUE Key는 행의 고유성을 보장하지만, PRIMARY Key처럼 각 행을 고유하게 식별하는 데는 사용되지 않습니다.
<br/>
</details>

<details>
<summary>2. 실시간 데이터 처리나 스트리밍 데이터 처리에는 RDB와 NoSQL 중 어떤 것이 더 적합하다고 생각하시나요?</summary>
실시간 데이터 처리나 스트리밍 데이터 처리에는 일반적으로 NoSQL이 더 적합합니다. 이는 NoSQL 데이터베이스가 대량의 데이터를 빠르게 쓰고 읽는 데 더 효율적이기 때문입니다. 또한 NoSQL 데이터베이스는 확장성이 뛰어나서 데이터 양이 증가하더라도 처리 성능을 유지하는 데 유리합니다.
<br/>
그러나 이는 단순히 일반적인 경우이며, 실제로는 사용하는 데이터의 특성, 애플리케이션의 요구 사항, 시스템의 인프라 등 여러 요인을 고려하여 결정해야 합니다.
<br/>
</details>

<details> 
<summary>3. 트랜잭션 충돌이 발생했을 때 어떻게 처리하나요?</summary>
트랜잭션 충돌, 즉 두 트랜잭션이 동시에 같은 데이터를 수정하려고 할 때 DBMS는 보통 락(lock) 메커니즘을 사용하여 이를 처리합니다. 락은 한 트랜잭션에서 사용 중인 데이터를 다른 트랜잭션에서 사용하지 못하도록 막습니다.
<br/>
또한, 충돌이 발생하면 DBMS는 보통 충돌을 일으킨 트랜잭션을 롤백(취소)하고, 해당 트랜잭션은 다시 시작하게 됩니다. 이런 방식으로 트랜잭션 충돌을 해결하며, 이를 통해 여러 트랜잭션을 동시에 안전하게 처리할 수 있습니다.
<br/>
</details>

<details> 
<summary>4. 트랜잭션 격리 레벨과 성능 간의 관계를 설명해주실 수 있나요?</summary>
트랜잭션 격리 레벨은 트랜잭션 처리의 정확성과 성능 사이의 트레이드오프를 결정합니다. 격리 레벨이 높을수록 동시에 수행되는 트랜잭션 간의 영향을 더 많이 제한하므로, 데이터의 일관성을 더 잘 보장할 수 있습니다. 그러나 이는 동시성을 제한하므로 성능에 부정적인 영향을 미칠 수 있습니다.
<br/>
반대로 격리 레벨이 낮을수록 더 많은 트랜잭션을 동시에 처리할 수 있으므로 성능이 향상될 수 있습니다. 하지만 이는 데이터의 일관성을 해칠 수 있으므로 주의해야 합니다.
<br/>
따라서 트랜잭션 격리 레벨을 선택할 때는 데이터의 일관성 요구 사항과 성능 요구 사항을 모두 고려해야 합니다.
<br/>
</details>

<details> 
<summary>5. 격리수준에 따라 발생할 수 있는 대표적인 현상중 더티리드, 팬텀리드, 논리피터블 리드 말고 다른 현상들이 있을까요?</summary>
대표적인 현상 외에도 트랜잭션 격리 수준에 따라 "비반복 가능 읽기(Non-repeatable Read)" 현상이 발생할 수 있습니다.
<br/>
비반복 가능 읽기는 한 트랜잭션 내에서 같은 데이터를 여러 번 읽을 때, 다른 트랜잭션에 의해 값이 변경되어서 같은 쿼리의 결과가 두 번 이상 반복해서 실행될 때 서로 다른 값을 반환하는 현상을 말합니다.
<br/>
이 현상은 REPEATABLE READ 또는 SERIALIZABLE 격리 수준에서 방지됩니다.
</details>

<details>
<summary>6. NoSql은 RDBMS와는 다르게 기본 격리수준이 read_uncommitted입니다 왜 그런걸까요?</summary>
NoSQL 데이터베이스는 대량의 데이터를 빠르게 쓰고 읽는 데 초점을 맞추고 있으며, 이를 위해 일부 일관성 제약 조건을 완화합니다. 이러한 완화된 일관성 모델 중 하나가 바로 READ UNCOMMITTED 격리 수준입니다.
<br/>
READ UNCOMMITTED 격리 수준에서는 다른 트랜잭션에서 아직 커밋되지 않은 변경 사항을 읽을 수 있습니다. 이는 성능을 향상시키지만, 동시에 일관성 문제를 발생시킬 수 있습니다. 그러나 NoSQL 데이터베이스는 보통 이러한 일관성 문제를 애플리케이션 레벨에서 해결하도록 설계되어 있습니다.
</details>

<details>
<summary>7. 한개의 트랜잭션 안에서 여러개의 트랜잭션이 있을경우, 트랜잭션 하나가 rollback이 일어나면 전체 트랜잭션은 어떻게 될까요?</summary>
한 개의 트랜잭션 안에서 여러 개의 트랜잭션이 있는 경우(이를 "중첩 트랜잭션"이라고 합니다), 하나의 트랜잭션이 롤백되면 그 트랜잭션에 의해 만들어진 모든 변경 사항이 취소됩니다. 그러나 이는 해당 트랜잭션만에 해당하며, 상위 트랜잭션에는 영향을 미치지 않습니다.
<br/>
다만, 만약 가장 바깥쪽에 있는 트랜잭션이 롤백되면, 해당 트랜잭션에 포함된 모든 중첩 트랜잭션의 변경 사항도 함께 취소됩니다.
<br/>
이는 트랜잭션의 원자성(Atomicity) 원칙에 따른 것입니다.
</details>

<details> 
<summary>8.RDBMS의 장점과 약점은 무엇인가요?</summary>
RDBMS의 장점:
<br/>
1. 구조화된 데이터: RDBMS는 데이터를 테이블로 구성하여 구조화된 형태로 저장합니다.데이터 관리를 용이하게 하고, 데이터의 일관성과 무결성을 유지하는 데 도움이 됩니다.
<br/>
2. 관계형 데이터 모델: RDBMS는 데이터 간의 관계를 표현하는 데 강점을 가지고 있습니다. 이를 통해 복잡한 쿼리와 분석이 가능합니다.
<br/>
RDBMS의 약점:
<br/>
확장성 문제: RDBMS는 대용량 데이터를 처리하는 데 어려움이 있습니다. 특히, 수직 확장(하드웨어의 업그레이드)보다는 수평 확장(다수의 서버에 분산 저장)이 필요한 상황에서는 한계가 있습니다.
<br/>
복잡한 트랜잭션 처리: 복잡한 트랜잭션을 처리하는 경우, 성능 저하가 발생할 수 있습니다.
<br/>
비정형 데이터 처리 어려움: 비정형 데이터를 처리하는 데는 한계가 있습니다.
<br/>
예를 들어, 텍스트, 이미지, 비디오 등의 비정형 데이터를 관리하는 데는 NoSQL과 같은 비관계형 데이터베이스가 더 효율적일 수 있습니다.
</details>

<details>
<summary>9. DB 데드락이 무엇인지 설명해주세요</summary>
데드락(Deadlock)이란 두 개 이상의 트랜잭션이 서로의 자원을 대기하는 상황을 말합니다.
<br/>
이 경우, 해당 트랜잭션들은 아무런 작업도 할 수 없게 되며, 이를 '데드락 상태'라고 합니다.
<br/>
따라서, 데드락은 데이터베이스 시스템의 성능을 저하시키는 주요 요인 중 하나입니다.
</details>

<details>
<summary>10.DB 데드락을 해결할 수 있는 방법이 있나요?</summary>
데드락을 해결하는 방법은 크게 두 가지로 나눌 수 있습니다.
<br/>
1. 데드락 예방: 데드락이 발생하지 않도록 하는 방법입니다. 
<br/>
예를 들어, 트랜잭션이 필요로 하는 모든 자원을 한 번에 요청하도록 하거나, 자원에 순서를 부여하여 순서대로만 자원을 획득하도록 하는 방법이 있습니다.
<br/>
2. 데드락 회피: 데드락이 발생할 가능성이 있는 상황을 미리 감지하고 회피하는 방법입니다. 
<br/>
이를 위해 데이터베이스 시스템은 트랜잭션들의 자원 요구 정보를 계속 추적하고, 데드락이 발생할 가능성이 있는 요청을 거부합니다.
<br/>
3.데드락 탐지 및 복구: 데드락이 발생한 후에 이를 탐지하고 복구하는 방법입니다.
<br/>
이 방법은 주기적으로 또는 데드락이 의심될 때 데드락을 탐지하고, 데드락을 해결하기 위해 하나 이상의 트랜잭션을 중단합니다.
</details>