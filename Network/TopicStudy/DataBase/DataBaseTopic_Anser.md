### ✅ 1. Key (기본키, 후보키, 슈퍼키 등등...) 에 대해 설명해 주세요.

<details> <summary>기본키, 후보키, 슈퍼키</summary>
기본키(Primary Key): 테이블에서 각 행의 고유함을 보장하는 데 사용되는 열입니다.NULL 값을 가질 수 없으며, 중복 값을 허용하지 않습니다.
<br/>
후보키(Candidate Key): 기본키가 될 수 있는 키로, 레코드를 고유하게 식별할 수 있는 속성 또는 속성 집합입니다.
<br/>
슈퍼키(Super Key): 레코드를 고유하게 식별할 수 있는 속성의 집합을 의미합니다. 후보키와 달리 슈퍼키는 최소성을 만족시키지 않아도 됩니다.
<br/>
</details>

---

<details> 
<summary>1. 기본키는 수정이 가능한가요?</summary>
기본키는 기본적으로 수정이 허용되지 않습니다. 기본키를 변경하면 테이블 간의 관계가 깨질 수 있습니다.
</details>

<details>
<summary>2. 사실 MySQL의 경우, 기본키를 설정하지 않아도 테이블이 만들어집니다. 어떻게 이게 가능한 걸까요?</summary>
    MySQL에서는 기본키를 설정하지 않으면 내부적으로 '인공키'라고 부르는 숨겨진 열을 생성하여 테이블의 각 행을 구별합니다.
    이렇게 하면 사용자가 명시적으로 기본키를 설정하지 않아도 테이블의 레코드를 유일하게 식별할 수 있습니다.
</details>

<details> 
<summary>3. 외래키 값은 NULL이 들어올 수 있나요?</summary>
외래키는 NULL 값을 가질 수 있습니다. 외래키가 NULL인 경우, 그 행은 참조 무결성 제약조건을 만족시킨다고 간주됩니다.
</details>

<details> 
<summary> 4. 어떤 칼럼의 정의에 UNIQUE 키워드가 붙는다고 가정해 봅시다. 이 칼럼을 활용한 쿼리의 성능은 그렇지 않은 것과 비교해서 어떻게 다를까요?</summary>
UNIQUE 키워드가 붙은 칼럼은 중복된 값을 가질 수 없으므로, DBMS는 해당 속성을 활용하여 쿼리의 성능을 향상시킬 수 있습니다.
특히, 해당 칼럼에 대한 SELECT, UPDATE, DELETE 쿼리는 인덱스를 활용하여 빠른 검색 속도를 제공합니다.
</details>
<br/>

### ✅ 2. RDB와 NoSQL의 차이에 대해 설명해 주세요.

<details> <summary>RDB와 NoSQL의 차이</summary>
RDB(Relational Database)는 관계형 데이터베이스로, 데이터를 테이블 형태로 저장하고 SQL을 사용하여 데이터를 관리합니다.
ACID 트랜잭션을 지원하며, 데이터의 무결성을 보장합니다.
<br/>
반면 NoSQL(Not only SQL)은 RDB의 제약을 극복하기 위해 등장한 데이터베이스로, Key-Value, Document, Column, Graph 등 다양한 데이터 모델을 지원합니다. 
대량의 데이터를 빠르게 처리하고 분산 처리를 지원하는 것이 특징입니다.
<br/>
</details>

---

<details> 
<summary>1. NoSQL의 강점과, 약점이 무엇인가요?</summary>
NoSQL의 강점: 대량의 데이터를 빠르게 처리하고, 분산 처리를 지원합니다.
스키마가 없거나 유연하기 때문에 데이터 구조 변경이 용이합니다.

<br/>
NoSQL의 약점: NoSQL 데이터베이스는 종종 RDBMS만큼 세부적인 보안 기능을 제공하지 않습니다. 예를 들어, 열 레벨의 보안이나 롤 기반 접근 제어 등을 제공하지 않을 수 있습니다.
<br/>
NoSQL 데이터베이스는 SQL만큼 강력한 쿼리 언어를 제공하지 않을 수 있어, 복잡한 쿼리를 만드는 데 사용 제한이 있을 수 있습니다.
그리고 ACID 트랜잭션을 완벽하게 지원하지 않을 수 있습니다.
<br/>
</details>


<details>
<summary>2. RDB의 어떠한 특징 때문에 NoSQL에 비해 부하가 많이 걸릴 "수" 있을까요? (주의: 무조건 NoSQL이 RDB 보다 빠르다라고 생각하면 큰일 납니다!)</summary>
RDB는 테이블 간의 관계를 유지하면서 ACID 트랜잭션을 보장하기 위해 많은 연산을 수행해야 합니다. 이 때문에 대량의 데이터를 처리하거나 복잡한 쿼리를 실행할 경우 부하가 많이 발생할 수 있습니다.
</details>

<details>
<summary>3. NoSQL을 활용한 경험이 있나요? 있다면, 왜 RDB를 선택하지 않고 해당 DB를 선택했는지 설명해 주세요.</summary>
저의 경우, Server-Sent Events(SSE)를 이용한 실시간 알람 서비스를 구현할 때 Redis를 사용한 경험이 있습니다. 이 때문에 RDB 대신 NoSQL 데이터베이스인 Redis를 선택했습니다.

Redis는 메모리 기반의 데이터 저장소로, 빠른 응답 시간과 고성능을 제공하며, 간단한 데이터 구조를 지원합니다. 이러한 특성 때문에 Redis는 실시간 애플리케이션에 특히 유용합니다.

이 프로젝트에서는 여러 서버 간의 메시지 전달을 위해 Redis의 Pub/Sub 기능을 활용했습니다. 이를 통해 서버 간에 메시지를 빠르게 공유하고, 동시에 여러 서버에서 동일한 알람을 받을 수 있었습니다.

RDB를 사용하지 않은 주요 이유는 두 가지입니다.
<br/>
첫째, 실시간 알람 서비스는 빠른 응답 시간이 필요하며, 이는 Redis가 제공하는 높은 성능을 필요로 합니다.
<br/>
둘째, 메시지 큐와 같은 간단한 데이터 구조는 Redis가 잘 지원하므로, 이러한 요구 사항을 충족시키기 위해 Redis를 선택했습니다.
</details>

<br/>

### ✅ 3. 트랜잭션이 무엇이고, ACID 원칙에 대해 설명해 주세요.

<details> 
<summary>트랜잭션</summary>
트랜잭션은 데이터베이스의 상태를 변화시키는 하나의 논리적인 작업 단위를 의미합니다. 그리고 트랜잭션은 ACID 원칙을 따릅니다.
</details>

<details> 
<summary>ACID란</summary>
Atomicity(원자성): 트랜잭션의 모든 작업이 완료되거나, 아니면 전혀 실행되지 않아야 함을 의미합니다.
<br/>
Consistency(일관성): 트랜잭션이 성공적으로 완료되면, 데이터베이스는 일관된 상태에 있어야 함을 의미합니다.
<br/>
Isolation(고립성): 각 트랜잭션은 서로 독립적으로 실행되어야 함을 의미합니다.
<br/>
Durability(영속성): 트랜잭션이 성공적으로 완료된 후에는, 그 결과는 영구적으로 반영되어야 함을 의미합니다.
</details>

---

<details> 
<summary> 1. ACID 원칙 중, Durability를 DBMS는 어떻게 보장하나요?</summary>
DBMS는 Durability를 보장하기 위해 트랜잭션이 성공적으로 완료된 후에 변경 사항을 디스크와 같은 영구 저장소에 쓰는 방식을 사용합니다.
<br/>
이 과정에서 로그 기반 복구나 체크포인트 등의 기법이 사용됩니다. 
<br/>
예를 들어, 트랜잭션이 성공적으로 완료된 후에는 해당 트랜잭션에 대한 로그를 디스크에 쓰게 되며, 시스템 장애가 발생한 경우 이 로그를 사용하여 데이터를 복구합니다.
</details>

<details> 
<summary>2. 트랜잭션을 사용해 본 경험이 있나요? 어떤 경우에 사용할 수 있나요?</summary>
서비스 레이어에서 트랜잭션을 활용한 경험이 있습니다. 
<br/>
서비스 레이어는 여러 데이터베이스 연산을 조합하여 하나의 비즈니스 로직을 구현하는 곳이기 때문에, 트랜잭션을 사용하여 여러 연산이 모두 성공하거나 모두 실패하도록 보장해야 하는 경우가 있습니다.
<br/>
예를 들어, 저는 "상품 주문"이라는 비즈니스 로직을 구현할 때 "주문 정보 저장", "재고 감소" 등의 연산을 하나의 트랜잭션으로 묶어 처리한 경험이 있습니다.
<br/>
이런 방식으로 트랜잭션을 사용하면, 모든 연산이 성공적으로 완료되지 않으면 롤백을 통해 이전 상태로 돌아가게 되므로, 데이터의 일관성을 유지하면서 안전하게 비즈니스 로직을 처리할 수 있습니다.
</details>

<details> 
<summary>3. 읽기에는 트랜잭션을 걸지 않아도 될까요?</summary>
읽기 작업에 트랜잭션을 사용할지 여부는 상황에 따라 다릅니다. 
만약 데이터의 일관성을 보장받아야 하는 경우(즉, 읽는 동안 다른 트랜잭션에 의해 데이터가 변경되는 것을 방지해야 하는 경우)에는 읽기 작업에도 트랜잭션을 사용해야 합니다.
</details>
<br/>

### ✅ 4. 트랜잭션 격리 레벨에 대해 설명해 주세요.

<details>
<summary>트랜잭션 격리 레벨</summary>
트랜잭션 격리 레벨은 동시에 여러 트랜잭션이 실행될 때 트랜잭션들이 서로 얼마나 영향을 미치는지를 결정하는 것입니다.
<br/>
SQL 표준에서는 다음과 같이 4개의 격리 레벨이 정의되어 있습니다
1. READ UNCOMMITTED 
<br/>
2. READ COMMITTED 
<br/>
3. REPEATABLE READ 
<br/>
4. SERIALIZABLE
</details>

---

<details> <summary>1. 모든 DBMS가 4개의 레벨을 모두 구현하고 있나요? 그렇지 않다면 그 이유는 무엇일까요?</summary>
모든 DBMS가 4개의 트랜잭션 격리 레벨을 모두 구현하고 있지는 않습니다.
<br/>
이는 각 DBMS의 내부 구현과 성능, 사용 사례 등에 따라 다릅니다.
<br/>
예를 들어, MySQL의 InnoDB 스토리지 엔진은 READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ, SERIALIZABLE의 4개의 격리 레벨을 제공하지만, 기본 격리 레벨은 REPEATABLE READ입니다.
</details>

<details> 
<summary>2. 만약 MySQL을 사용하고 있다면, (InnoDB 기준) Undo 영역과 Redo 영역에 대해 설명해 주세요.</summary>
MySQL의 InnoDB 스토리지 엔진은 트랜잭션 처리와 복구를 위해 Undo 영역과 Redo 영역을 사용합니다.
<br/>
Undo 영역: 이 영역은 트랜잭션이 롤백되어야 할 때 이전 상태로 되돌릴 수 있도록 데이터 변경 내역을 저장합니다. 또한, 다른 트랜잭션에서 변경된 데이터를 고립된 상태로 볼 수 있게 하는 데에도 사용됩니다.
<br/>
Redo 영역: 이 영역은 시스템 장애가 발생했을 때 데이터를 복구하는 데 사용됩니다. 트랜잭션이 커밋되었을 때, 변경 내역은 디스크에 바로 기록되지 않고 Redo 로그 버퍼에 먼저 기록되며, 이후에 디스크에 기록됩니다
<br/>
</details>

<details> 
<summary>3. 그런데, 스토리지 엔진이 정확히 무엇을 하는 건가요?</summary>
스토리지 엔진은 DBMS에서 데이터의 저장, 검색, 관리 방식을 결정하는 핵심 컴포넌트입니다.
이는 테이블의 구조, 인덱싱, 트랜잭션 처리, 데이터 복구 등을 담당합니다.
따라서 사용하는 스토리지 엔진에 따라 DBMS의 성능, 복구 기능, 트랜잭션 처리 방식 등이 달라집니다.
</details>
<br/>
