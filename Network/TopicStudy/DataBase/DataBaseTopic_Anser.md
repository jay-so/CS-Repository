### ✅ 1. Key (기본키, 후보키, 슈퍼키 등등...) 에 대해 설명해 주세요.

<details> <summary>기본키, 후보키, 슈퍼키</summary>
기본키(Primary Key): 테이블에서 각 행의 고유함을 보장하는 데 사용되는 열입니다.NULL 값을 가질 수 없으며, 중복 값을 허용하지 않습니다.
<br/>
후보키(Candidate Key): 기본키가 될 수 있는 키로, 레코드를 고유하게 식별할 수 있는 속성 또는 속성 집합입니다.
<br/>
슈퍼키(Super Key): 레코드를 고유하게 식별할 수 있는 속성의 집합을 의미합니다. 후보키와 달리 슈퍼키는 최소성을 만족시키지 않아도 됩니다.
<br/>
</details>

---

<details> 
<summary>1. 기본키는 수정이 가능한가요?</summary>
기본키는 기본적으로 수정이 허용되지 않습니다. 기본키를 변경하면 테이블 간의 관계가 깨질 수 있습니다.
</details>

<details>
<summary>2. 사실 MySQL의 경우, 기본키를 설정하지 않아도 테이블이 만들어집니다. 어떻게 이게 가능한 걸까요?</summary>
    MySQL에서는 기본키를 설정하지 않으면 내부적으로 '인공키'라고 부르는 숨겨진 열을 생성하여 테이블의 각 행을 구별합니다.
    이렇게 하면 사용자가 명시적으로 기본키를 설정하지 않아도 테이블의 레코드를 유일하게 식별할 수 있습니다.
</details>

<details> 
<summary>3. 외래키 값은 NULL이 들어올 수 있나요?</summary>
외래키는 NULL 값을 가질 수 있습니다. 외래키가 NULL인 경우, 그 행은 참조 무결성 제약조건을 만족시킨다고 간주됩니다.
</details>

<details> 
<summary> 4. 어떤 칼럼의 정의에 UNIQUE 키워드가 붙는다고 가정해 봅시다. 이 칼럼을 활용한 쿼리의 성능은 그렇지 않은 것과 비교해서 어떻게 다를까요?</summary>
UNIQUE 키워드가 붙은 칼럼은 중복된 값을 가질 수 없으므로, DBMS는 해당 속성을 활용하여 쿼리의 성능을 향상시킬 수 있습니다.
특히, 해당 칼럼에 대한 SELECT, UPDATE, DELETE 쿼리는 인덱스를 활용하여 빠른 검색 속도를 제공합니다.
</details>
<br/>

### ✅ 2. RDB와 NoSQL의 차이에 대해 설명해 주세요.

<details> <summary>RDB와 NoSQL의 차이</summary>
RDB(Relational Database)는 관계형 데이터베이스로, 데이터를 테이블 형태로 저장하고 SQL을 사용하여 데이터를 관리합니다.
ACID 트랜잭션을 지원하며, 데이터의 무결성을 보장합니다.
<br/>
반면 NoSQL(Not only SQL)은 RDB의 제약을 극복하기 위해 등장한 데이터베이스로, Key-Value, Document, Column, Graph 등 다양한 데이터 모델을 지원합니다. 
대량의 데이터를 빠르게 처리하고 분산 처리를 지원하는 것이 특징입니다.
<br/>
</details>

---

<details> 
<summary>1. NoSQL의 강점과, 약점이 무엇인가요?</summary>
NoSQL의 강점: 대량의 데이터를 빠르게 처리하고, 분산 처리를 지원합니다.
스키마가 없거나 유연하기 때문에 데이터 구조 변경이 용이합니다.

<br/>
NoSQL의 약점: NoSQL 데이터베이스는 종종 RDBMS만큼 세부적인 보안 기능을 제공하지 않습니다. 예를 들어, 열 레벨의 보안이나 롤 기반 접근 제어 등을 제공하지 않을 수 있습니다.
<br/>
NoSQL 데이터베이스는 SQL만큼 강력한 쿼리 언어를 제공하지 않을 수 있어, 복잡한 쿼리를 만드는 데 사용 제한이 있을 수 있습니다.
그리고 ACID 트랜잭션을 완벽하게 지원하지 않을 수 있습니다.
<br/>
</details>

<br/>

<details>
<summary>2. RDB의 어떠한 특징 때문에 NoSQL에 비해 부하가 많이 걸릴 "수" 있을까요? (주의: 무조건 NoSQL이 RDB 보다 빠르다라고 생각하면 큰일 납니다!)</summary>
RDB는 테이블 간의 관계를 유지하면서 ACID 트랜잭션을 보장하기 위해 많은 연산을 수행해야 합니다. 이 때문에 대량의 데이터를 처리하거나 복잡한 쿼리를 실행할 경우 부하가 많이 발생할 수 있습니다.
</details>
<br/>

<details>
<summary>3. NoSQL을 활용한 경험이 있나요? 있다면, 왜 RDB를 선택하지 않고 해당 DB를 선택했는지 설명해 주세요.</summary>
저의 경우, Server-Sent Events(SSE)를 이용한 실시간 알람 서비스를 구현할 때 Redis를 사용한 경험이 있습니다. 이 때문에 RDB 대신 NoSQL 데이터베이스인 Redis를 선택했습니다.

Redis는 메모리 기반의 데이터 저장소로, 빠른 응답 시간과 고성능을 제공하며, 간단한 데이터 구조를 지원합니다. 이러한 특성 때문에 Redis는 실시간 애플리케이션에 특히 유용합니다.

이 프로젝트에서는 여러 서버 간의 메시지 전달을 위해 Redis의 Pub/Sub 기능을 활용했습니다. 이를 통해 서버 간에 메시지를 빠르게 공유하고, 동시에 여러 서버에서 동일한 알람을 받을 수 있었습니다.

RDB를 사용하지 않은 주요 이유는 두 가지입니다.
<br/>
첫째, 실시간 알람 서비스는 빠른 응답 시간이 필요하며, 이는 Redis가 제공하는 높은 성능을 필요로 합니다.
<br/>
둘째, 메시지 큐와 같은 간단한 데이터 구조는 Redis가 잘 지원하므로, 이러한 요구 사항을 충족시키기 위해 Redis를 선택했습니다.
</details>

<br/>

### ✅ 3. 트랜잭션이 무엇이고, ACID 원칙에 대해 설명해 주세요.

<details> 
<summary>트랜잭션</summary>
트랜잭션은 데이터베이스의 상태를 변화시키는 하나의 논리적인 작업 단위를 의미합니다. 그리고 트랜잭션은 ACID 원칙을 따릅니다.
</details>

<br/>

<details> 
<summary>ACID란</summary>
Atomicity(원자성): 트랜잭션은 데이터베이스에 모두 반영되거나, 전혀 반영되지 않아야 함을 의미합니다.
<br/>
Consistency(일관성): 트랜잭션이 성공적으로 완료되면, 데이터베이스는 일관된 상태에 있어야 함을 의미합니다.
<br/>
Isolation(고립성): 각 트랜잭션은 서로 독립적으로 실행되어야 함을 의미합니다.
<br/>
Durability(영속성): 트랜잭션이 성공적으로 완료된 후에는, 그 결과는 영구적으로 반영되어야 함을 의미합니다.
</details>

---

<details> 
<summary> 1. ACID 원칙 중, Durability를 DBMS는 어떻게 보장하나요?</summary>
DBMS는 Durability를 보장하기 위해 트랜잭션이 성공적으로 완료된 후에 변경 사항을 디스크와 같은 영구 저장소에 쓰는 방식을 사용합니다.
<br/>
이 과정에서 로그 기반 복구나 체크포인트 등의 기법이 사용됩니다. 
<br/>
예를 들어, 트랜잭션이 성공적으로 완료된 후에는 해당 트랜잭션에 대한 로그를 디스크에 쓰게 되며, 시스템 장애가 발생한 경우 이 로그를 사용하여 데이터를 복구합니다.
</details>

<br/>

<details> 
<summary>2. 트랜잭션을 사용해 본 경험이 있나요? 어떤 경우에 사용할 수 있나요?</summary>
서비스 레이어에서 트랜잭션을 활용한 경험이 있습니다. 
<br/>
서비스 레이어는 여러 데이터베이스 연산을 조합하여 하나의 비즈니스 로직을 구현하는 곳이기 때문에, 트랜잭션을 사용하여 여러 연산이 모두 성공하거나 모두 실패하도록 보장해야 하는 경우가 있습니다.
<br/>
예를 들어, 저는 "상품 주문"이라는 비즈니스 로직을 구현할 때 "주문 정보 저장", "재고 감소" 등의 연산을 하나의 트랜잭션으로 묶어 처리한 경험이 있습니다.
<br/>
이런 방식으로 트랜잭션을 사용하면, 모든 연산이 성공적으로 완료되지 않으면 롤백을 통해 이전 상태로 돌아가게 되므로, 데이터의 일관성을 유지하면서 안전하게 비즈니스 로직을 처리할 수 있습니다.
</details>

<br/>

<details> 
<summary>3. 읽기에는 트랜잭션을 걸지 않아도 될까요?</summary>
읽기 작업에 트랜잭션을 사용할지 여부는 상황에 따라 다릅니다. 
만약 데이터의 일관성을 보장받아야 하는 경우(즉, 읽는 동안 다른 트랜잭션에 의해 데이터가 변경되는 것을 방지해야 하는 경우)에는 읽기 작업에도 트랜잭션을 사용해야 합니다.
</details>
<br/>

### ✅ 4. 트랜잭션 격리 레벨에 대해 설명해 주세요.

<details>
<summary>트랜잭션 격리 레벨</summary>
트랜잭션 격리 레벨은 동시에 여러 트랜잭션이 실행될 때 트랜잭션들이 서로 얼마나 영향을 미치는지를 결정하는 것입니다.
<br/>
SQL 표준에서는 다음과 같이 4개의 격리 레벨이 정의되어 있습니다
<br/>
1. READ UNCOMMITTED 
<br/>
2. READ COMMITTED 
<br/>
3. REPEATABLE READ 
<br/>
4. SERIALIZABLE
</details>

---

<details> <summary>1. 모든 DBMS가 4개의 레벨을 모두 구현하고 있나요? 그렇지 않다면 그 이유는 무엇일까요?</summary>
모든 DBMS가 4개의 트랜잭션 격리 레벨을 모두 구현하고 있지는 않습니다.
<br/>
이는 각 DBMS의 내부 구현과 성능, 사용 사례 등에 따라 다릅니다.
<br/>
예를 들어, MySQL의 InnoDB 스토리지 엔진은 READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ, SERIALIZABLE의 4개의 격리 레벨을 제공하지만, 기본 격리 레벨은 REPEATABLE READ입니다.
</details>

<br/>

<details> 
<summary>2. 만약 MySQL을 사용하고 있다면, (InnoDB 기준) Undo 영역과 Redo 영역에 대해 설명해 주세요.</summary>
MySQL의 InnoDB 스토리지 엔진은 트랜잭션 처리와 복구를 위해 Undo 영역과 Redo 영역을 사용합니다.
<br/>
Undo 영역: 이 영역은 트랜잭션이 롤백되어야 할 때 이전 상태로 되돌릴 수 있도록 데이터 변경 내역을 저장합니다. 또한, 다른 트랜잭션에서 변경된 데이터를 고립된 상태로 볼 수 있게 하는 데에도 사용됩니다.
<br/>
Redo 영역: 이 영역은 시스템 장애가 발생했을 때 데이터를 복구하는 데 사용됩니다. 트랜잭션이 커밋되었을 때, 변경 내역은 디스크에 바로 기록되지 않고 Redo 로그 버퍼에 먼저 기록되며, 이후에 디스크에 기록됩니다
<br/>
</details>

<br/>

<details> 
<summary>3. 그런데, 스토리지 엔진이 정확히 무엇을 하는 건가요?</summary>
스토리지 엔진은 DBMS에서 데이터의 저장, 검색, 관리 방식을 결정하는 핵심 컴포넌트입니다.
이는 테이블의 구조, 인덱싱, 트랜잭션 처리, 데이터 복구 등을 담당합니다.
따라서 사용하는 스토리지 엔진에 따라 DBMS의 성능, 복구 기능, 트랜잭션 처리 방식 등이 달라집니다.
</details>
<br/>

### ✅ 5. 인덱스가 무엇이고, 언제 사용하는지 설명해 주세요.

<details>
<summary>인덱스의 정의와 사용 예시</summary>
인덱스는 데이터베이스에서 데이터 검색 속도를 높이기 위한 자료구조이다.
인덱스는 마치 책의 색인과 같이 특정한 값을 가진 데이터의 위치 정보를 가지고 있습니다.
이를 통해 데이터 검색 시 전체 데이터를 검색하는 풀 스캔이 아닌, 인덱스를 통해 빠르게 데이터의 위치를 찾아 접근할 수 있습니다.
</details>
<br/>

---

<details> 
<summary>1. 일반적으로 인덱스는 수정이 잦은 테이블에선 사용하지 않기를 권합니다. 왜 그럴까요?</summary>
인덱스는 데이터베이스에서 데이터 검색 속도를 높이는 역할을 합니다. 
그러나 데이터가 변경될 때마다 인덱스 또한 함께 업데이트되어야 합니다.
따라서, 데이터의 수정이 빈번하게 일어나는 테이블에서는 인덱스를 사용하면 인덱스의 잦은 업데이트로 인한 오버헤드가 발생하여 성능 저하가 일어날 수 있습니다.
</details>
<br/>

<details> 
<summary>2. 앞 꼬리질문에 대해, 그렇다면 인덱스에서 사용하지 않겠다고 선택한 값은 위 정책을 그대로 따라가나요?</summary>
인덱스에서 사용하지 않겠다고 선택한 값은 위 정책을 따르기도 하지만, 데이터의 종류, 사용 빈도 등에 따라 다르게 적용될 수 있습니다. 
예를 들어, 검색 빈도가 낮거나, 데이터의 분포가 균일하지 않는 경우 인덱스의 효율이 떨어질 수 있으므로 해당 경우, 인덱스에서 제외될 수 있습니다.
</details> 
<br/>

<details> 
<summary>3. ORDER BY/GROUP BY 연산의 동작 과정을 인덱스의 존재여부와 연관지어서 설명해 주세요.</summary>
인덱스가 존재하면 ORDER BY나 GROUP BY 연산은 인덱스를 이용하여 훨씬 빠르게 동작할 수 있습니다.
인덱스는 이미 정렬된 상태로 데이터의 위치 정보를 가지고 있기 때문에 인덱스를 스캔하면서 바로 정렬 또는 그룹화를 수행할 수 있습니다.
반면 인덱스가 없으면 전체 데이터를 스캔하고 정렬 또는 그룹화를 수행해야 하므로 처리 시간이 더 많이 소요됩니다.
</details>
<br/>

<details>
<summary>4.기본키는 인덱스라고 할 수 있을까요? 그렇지 않다면, 인덱스와 기본키는 어떤 차이가 있나요?</summary>
기본키는 테이블의 각 행을 유일하게 식별하는 역할을 하며, 자동으로 인덱스가 생성됩니다.
따라서 기본키는 인덱스의 일종이라고 볼 수 있습니다. 
하지만 기본키는 테이블에서 단 하나만 존재할 수 있고, NULL 값을 허용하지 않는 등 인덱스와는 차이점이 있습니다. 
인덱스는 중복 값을 허용하며, 여러 개를 설정할 수 있습니다.
</details>
<br/>

<details>
<summary>5.그렇다면 외래키는요?</summary>
외래키 또한 인덱스로 사용될 수 있습니다. 외래키는 다른 테이블의 기본키를 참조하는 키로, 참조 무결성을 보장하는데 사용됩니다.
외래키에 인덱스를 사용하면 JOIN 연산 등에서 성능을 향상시키는 데 도움이 됩니다.
</details>
<br/>

<details>
<summary>6.인덱스가 데이터의 물리적 저장에도 영향을 미치나요? 그렇지 않다면, 데이터는 어떤 순서로 물리적으로 저장되나요?</summary>
인덱스는 데이터의 물리적인 저장 순서에 영향을 주지 않습니다. 인덱스는 데이터의 위치 정보를 가지고 있지만, 이는 데이터가 실제로 저장된 디스크의 위치를 나타내는 것이지, 데이터의 물리적인 저장 순서를 결정하는 것은 아닙니다. 
데이터의 물리적 저장 순서는 데이터베이스 관리 시스템(DBMS)의 파일 시스템에 따라 결정됩니다.
</details>
<br/>

<details>
<summary>7.우리가 아는 RDB가 아닌 NoSQL (ex. Redis, MongoDB 등)는 인덱스를 갖고 있나요? 만약 있다면, RDB의 인덱스와는 어떤 차이가 있을까요?</summary>
NoSQL 데이터베이스 또한 인덱스를 가질 수 있습니다. 하지만 RDB와는 달리 NoSQL의 인덱스는 스키마가 고정되지 않아, 동적으로 변경되는 데이터에 대해 유연하게 인덱스를 적용할 수 있습니다.
또한, NoSQL 데이터베이스는 대량의 데이터를 처리하는 데 특화되어 있기 때문에, 이에 맞는 다양한 인덱스 구조를 제공합니다.
</details>
<br/>

<details>
<summary>8.(A, B) 와 같은 방식으로 인덱스를 설정한 테이블에서, A 조건 없이 B 조건만 사용하여 쿼리를 요청했습니다. 해당 쿼리는 인덱스를 탈까요?</summary>
(A, B)와 같은 복합 인덱스에서 A 조건 없이 B 조건만 사용하여 쿼리를 요청하면, 해당 쿼리는 인덱스를 사용하지 않습니다. 복합 인덱스는 왼쪽부터 읽혀지기 때문에, A 조건이 없으면 B 조건에 대한 인덱스를 찾을 수 없습니다.
</details>
<br/>

### ✅ 6. RDBMS, NoSQL에서의 클러스터링/레플리케이션 방식에 대해 설명해 주세요.

<details>
<summary>클러스터링/레플리케이션의 정의</summary>
클러스터링: 클러스터링은 여러 서버(노드)가 하나의 데이터베이스를 공유하도록 구성하는 것을 의미합니다. 
이를 통해 데이터베이스의 성능을 향상시키고, 가용성을 높일 수 있습니다.
RDBMS에서는 클러스터링을 위해 종종 샤딩을 사용하여 데이터를 여러 서버에 분산합니다.
NoSQL에서는 일반적으로 분산 처리를 위해 클러스터링을 사용합니다.
<br/>
레플리케이션: 레플리케이션은 데이터를 여러 노드에 복제하는 것을 의미합니다. 
이를 통해 데이터의 가용성을 높이고, 시스템의 부하를 분산할 수 있습니다. RDBMS에서는 주로 마스터-슬레이브 레플리케이션을 사용합니다.
마스터 노드에서 발생하는 모든 변경사항이 슬레이브 노드에 복제됩니다. NoSQL에서는 종종 다중 마스터 레플리케이션을 사용합니다.
모든 노드가 동일한 권한을 가지며, 어느 노드에서든 변경사항을 적용할 수 있습니다.
</details>

---

<details>
<summary>1.이러한 분산 환경에선, 트랜잭션을 어떻게 관리할 수 있을까요?</summary>
분산 트랜잭션은 여러 노드에 걸쳐 수행되는 트랜잭션을 의미하며, 이를 위한 대표적인 프로토콜로는 2단계 커밋(2PC, Two-Phase Commit)과 3단계 커밋(3PC, Three-Phase Commit)이 있습니다.
<br/>
2PC는 모든 참여 노드에게 커밋 의사를 묻는 투표 단계와 실제 커밋을 수행하는 단계로 이루어집니다. 하지만 이 방식은 한 노드가 실패할 경우 전체 시스템이 블로킹되는 문제가 있습니다.
<br/>
3PC는 이 문제를 해결하기 위해 타임아웃과 같은 메커니즘을 도입해, 노드의 실패에도 블로킹 없이 트랜잭션을 진행할 수 있도록 합니다.
<br/>
그러나 이런 방식도 네트워크 지연, 노드 장애 등의 문제로 인해 완전한 일관성을 보장하기 어렵습니다. 따라서 분산 환경에서는 종종 '최종적 일관성'이라는 느슨한 일관성 모델을 사용하기도 합니다.
</details>
<br/>

<details>
<summary>2.마스터, 슬레이브 데이터 동기화 전 까지의 데이터 정합성을 지키는 방법은 무엇이 있을까요?</summary>
마스터-슬레이브 구조에서는 보통 비동기적인 방식으로 레플리케이션이 이루어집니다. 
이 경우 마스터와 슬레이브 사이의 데이터 불일치가 발생할 수 있습니다. 이러한 문제를 해결하기 위한 방법으로는 다음과 같은 방법이 있습니다.
<br/>
1.세미-동기 레플리케이션: 마스터는 트랜잭션을 커밋하기 전에 적어도 하나의 슬레이브에 데이터가 복제되었음을 확인합니다. 이 방식은 데이터 불일치 확률을 줄일 수 있지만, 마스터의 성능에 영향을 줄 수 있습니다.
<br/>
2.레드 로그(Write-Ahead Logging): 마스터는 모든 변경을 먼저 로그에 기록하고, 이 로그를 슬레이브에 전송합니다. 슬레이브는 로그를 순차적으로 재생하여 데이터를 동기화합니다.
<br/>
3.마스터에서 슬레이브로의 변경 전파 지연: 네트워크 지연이나 슬레이브의 처리 지연 등으로 인해 변경이 즉시 전파되지 않을 수 있습니다. 이 경우 주기적인 스냅샷, 로그 기반의 복구 등을 활용해 데이터 정합성을 유지할 수 있습니다.
</details>
<br/>

<details>
<summary>3.다중 트랜잭션 상황에서의 Deadlock 상황과, 이를 해결하기 위한 방법에 대해 설명해 주세요.</summary>
Deadlock은 두 개 이상의 트랜잭션이 각각 다른 트랜잭션이 소유한 자원을 기다리면서 무한 대기 상태에 빠지는 현상을 말합니다. 이를 해결하기 위한 방법으로는 다음과 같은 방법들이 있습니다
<br/>
1.자원 할당 그래프를 사용하여 사이클을 감지하고, 이를 통해 교착 상태를 예방하거나 회피합니다.
2.시스템이 교착 상태를 주기적으로 검사하고, 발견될 경우 트랜잭션 중 하나를 선택하여 중단(롤백)시키는 방법입니다.
3.트랜잭션에 우선순위를 부여하여, 낮은 우선순위의 트랜잭션을 중단시키는 방법입니다.
4.트랜잭션에 시간 제한을 설정하여, 제한 시간 내에 완료되지 않는 트랜잭션을 중단시키는 방법입니다.
</details>
<br/>

<details>
<summary>4.샤딩 방식은 무엇인가요? 만약 본인이 DB를 분산해서 관리해야 한다면, 레플리케이션 방식과 샤딩 방식 중 어떤 것을 사용할 것 같나요?</summary>
샤딩은 데이터베이스를 여러 파티션으로 나누는 방법입니다. 각 파티션은 독립적인 데이터베이스로 작동하며, 데이터의 일부를 저장하고 관리합니다. 
샤딩은 대량의 데이터를 다루고, 성능과 가용성을 향상시키는 데 효과적입니다.
<br/>
레플리케이션과 샤딩은 각각 다른 문제를 해결하기 위한 방법입니다.
레플리케이션은 데이터의 복사본을 여러 노드에 분산시킴으로써 데이터의 가용성을 높이고, 시스템의 부하를 분산시키는 데 사용됩니다. 
반면, 샤딩은 데이터를 여러 노드에 분할하여 저장함으로써, 대량의 데이터를 관리하고, 쿼리 성능을 향상시키는 데 사용됩니다.
<br/>
따라서 DB를 분산해서 관리한다면, 어떤 방식을 사용할지는 시스템의 요구 사항과 목표에 따라 달라집니다.
데이터의 가용성이 중요한 경우에는 레플리케이션을, 대량의 데이터를 빠르게 처리해야 하는 경우에는 샤딩을 고려할 수 있습니다.
</details>
<br/>

### ✅ 7. 정규화가 무엇인가요?

<details>
<summary> 정규화의 정의</summary>
데이터베이스의 정규화는 데이터의 중복을 최소화하고, 데이터베이스 구조를 효율적으로 만들기 위한 과정입니다. 이는 데이터의 무결성과 일관성을 향상시킵니다.
<br/>
정규화의 목적은 데이터베이스에서 중복된 데이터를 제거하고, 데이터의 구조를 향상시키는 것입니다. 
데이터의 중복을 제거함으로써 데이터의 갱신, 삽입, 삭제 시 발생할 수 있는 이상 현상을 방지할 수 있습니다.
</details>

---

<details>
<summary>1.정규화를 하지 않을 경우, 발생할 수 있는 이상현상에 대해 설명해 주세요.</summary>
정규화를 하지 않을 경우, 다음과 같은 이상 현상(Anomalies)이 발생할 수 있습니다.
<br/>
1. 삽입 이상 (Insertion Anomaly): 불필요한 데이터까지 입력해야 하는 문제입니다. 예를 들어, 학생과 과목에 대한 정보를 같이 저장하는 테이블에서 새 과목을 추가하려면, 학생 정보 없이는 과목 정보만을 추가할 수 없습니다.
<br/>
2. 갱신 이상 (Update Anomaly): 일부만 변경되어 데이터 불일치가 발생하는 문제입니다. 예를 들어, 동일한 학생 정보가 여러 행에 걸쳐 저장되어 있는데, 이 중 일부만 갱신되면 정보의 일관성이 깨집니다.
<br/>
3. 삭제 이상 (Deletion Anomaly): 의도하지 않은 정보 손실이 발생하는 문제입니다. 예를 들어, 학생이 수강하는 마지막 과목을 삭제하면, 해당 학생에 대한 정보까지 같이 삭제될 수 있습니다.
</details>
<br/>

<details>
<summary>2.각 정규화에 대해, 그 정규화가 진행되기 전/후의 테이블의 변화에 대해 설명해 주세요.</summary>
제1정규화: 각 컬럼의 값이 원자적(Atomic)해야 합니다. 즉, 하나의 컬럼에는 하나의 값만 있어야 하며, 여러 값을 가지려면 별도의 테이블로 분리해야 합니다.
<br/>
제2정규화: 제1정규화를 만족하며, 기본키가 아닌 모든 컬럼이 기본키에 완전 함수 종속해야 합니다. 즉, 기본키의 일부에 종속된 컬럼이 있으면 별도의 테이블로 분리해야 합니다.
<br/>
제3정규화: 제2정규화를 만족하며, 기본키가 아닌 모든 컬럼이 기본키에 대해 이행적 함수 종속이 없어야 합니다. 즉, 기본키가 아닌 컬럼 간에 종속성이 있으면 별도의 테이블로 분리해야 합니다.
<br/>
BCNF(Boyce-Codd Normal Form): 제3정규화를 만족하며, 모든 결정자가 후보키(Candidate Key) 부분 집합이어야 합니다. 즉, 후보키가 아닌 결정자가 있으면 별도의 테이블로 분리해야 합니다.
<br/>
</details>
<br/>

<details>
<summary>3.정규화가 무조건 좋은가요? 그렇지 않다면, 어떤 상황에서 역정규화를 하는게 좋은지 설명해 주세요.</summary>
정규화는 데이터의 중복을 제거하고, 데이터의 일관성을 유지하는데 효과적입니다.
하지만, 너무 많은 정규화로 인해 테이블이 과도하게 분리되면, JOIN 연산이 빈번하게 발생하여 성능이 저하될 수 있습니다.
또한, 데이터를 읽는 쿼리가 주로 발생하고, 데이터 갱신이 잦지 않은 경우에는 데이터의 중복이 일부 발생하더라도, 데이터의 조회 성능을 향상시키기 위해 역정규화를 고려할 수 있습니다.
<br/>
역정규화는 정규화된 테이블을 재조정하여 성능을 향상시키거나, 데이터 관리를 단순화하는 과정입니다. 
이는 테이블의 조인을 줄이거나, 계산된 값을 미리 저장하는 등의 방법으로 수행됩니다. 
역정규화는 신중하게 수행되어야 하며, 데이터의 일관성 유지 등에 대한 추가적인 관리가 필요합니다.
</details>
<br/>

### ✅ 8. View가 무엇이고, 언제 사용할 수 있나요?

---

<details>
<summary> View가 정의, 사용 예시</summary>
View는 데이터베이스에서 사용자가 특정한 데이터 선택 혹은 조작을 통해 가상 테이블로 만든 결과를 말합니다.
이는 실제 테이블에 저장되는 데이터가 아니라, 하나 이상의 테이블에서 데이터를 조회하기 위해 사용되는 SQL 문의 저장된 결과라고 할 수 있습니다. View를 사용하는 주된 이유는 복잡한 쿼리를 단순화시키고, 데이터 접근을 제어하여 보안을 강화하기 위함입니다. 
또한, 데이터베이스의 구조 변경 시 기존의 애플리케이션 코드를 변경하지 않고도 View를 통해 해당 변경사항을 관리할 수 있는 장점이 있습니다.
따라서, 사용자는 데이터베이스의 복잡성을 숨기고, 필요한 정보만을 제공받기 위해 View를 사용할 수 있습니다.
</details>
<br/>

<details>
<summary>1. 그렇다면, View의 값을 수정해도 실제 테이블에는 반영되지 않나요?</summary>
View에 대한 수정은 일부 제한적인 상황을 제외하고는 실제 테이블에 반영됩니다.
기본적으로, View는 기반이 되는 테이블의 데이터를 조회하기 위한 것이므로, View를 통해 데이터를 수정하면 그 변경사항이 실제 테이블에도 반영됩니다.
하지만, 모든 View가 수정 가능한 것은 아닙니다. 
예를 들어, 여러 테이블을 조인하여 만든 View나, 집계 함수(예: SUM, COUNT 등)를 사용한 View, DISTINCT 키워드를 사용한 View 등은 수정할 수 없습니다.
따라서, View를 통해 데이터를 수정하고자 할 때는 해당 View가 수정 가능한지, 수정 시 기반 테이블에 어떤 영향을 미칠지를 사전에 잘 확인해야 합니다.
</details>
<br/>

### ✅ 9.DB Join이 무엇인지 설명하고, 각각의 종류에 대해서 설명해주세요.

---

<details>
<summary> DB Join 정의 및 종류 </summary>
DB Join은 두 개 이상의 테이블을 연결하여 데이터를 검색하는 방법입니다.
이를 통해, 서로 관련 있는 데이터를 여러 테이블에서 조합하여 하나의 결과로 보여줍니다.
주요 Join 유형에는 다음과 같은 것들이 있습니다.

1. **INNER JOIN**: 두 테이블 모두에서 일치하는 데이터가 있는 경우에만 결과를 반환합니다.
2. **LEFT JOIN (LEFT OUTER JOIN)**: 왼쪽 테이블의 모든 레코드와 오른쪽 테이블에서 일치하는 레코드를 반환합니다. 오른쪽 테이블에 일치하는 것이 없으면 결과는 NULL이 됩니다.
3. **RIGHT JOIN (RIGHT OUTER JOIN)**: 오른쪽 테이블의 모든 레코드와 왼쪽 테이블에서 일치하는 레코드를 반환합니다. 왼쪽 테이블에 일치하는 것이 없으면 결과는 NULL이 됩니다.
4. **FULL JOIN (FULL OUTER JOIN)**: 왼쪽 테이블과 오른쪽 테이블 양쪽 모두에서 일치하는 레코드를 반환합니다. 한쪽에만 일치하는 레코드가 있는 경우, 다른 한쪽은 NULL로 표시됩니다.
5. **CROSS JOIN**: 두 테이블 간의 가능한 모든 조합을 반환합니다.
6. **SELF JOIN**: 같은 테이블을 조인하는 것을 말하며, 테이블을 두 번 복사하여 조인하는 것과 유사합니다.

</details>
<br/>

<details>
<summary>1. 사실, JOIN은 상당한 시간이 걸릴 수 있기에 내부적으로 다양한 구현 방식을 사용하고 있습니다. 그 예시에 대해 설명해 주세요.</summary>
JOIN 연산을 수행할 때, 데이터베이스 관리 시스템(DBMS)은 효율성을 위해 여러 가지 최적화 방법을 사용합니다.
예를 들어, 다음과 같은 방식을 사용할 수 있습니다.

1. **중첩 루프 조인 (Nested Loop Join)**: 한 테이블의 각 행에 대해 다른 테이블을 순회하며 조건에 맞는 행을 찾습니다. 작은 데이터 세트에서 효율적일 수 있습니다.
2. **해시 조인 (Hash Join)**: 하나의 테이블에서 조인 키를 기반으로 해시 테이블을 생성하고, 다른 테이블을 순회하며 해시 테이블을 조회하여 매칭되는 행을 찾습니다. 대규모 데이터 세트에서 효율적일 수
   있습니다.
3. **소트-머지 조인 (Sort-Merge Join)**: 두 테이블을 조인 키 기준으로 정렬한 다음, 정렬된 순서를 기반으로 행을 매칭합니다. 조인 키가 이미 정렬되어 있거나, 결과가 정렬된 형태로 필요한 경우
   유리합니다.

</details>
<br/>

<details>
<summary>2. 그렇다면 입력한 쿼리에서 어떤 구현 방식을 사용하는지는 어떻게 알 수 있나요?</summary>
입력한 쿼리에서 사용되는 구현 방식을 알아보는 가장 좋은 방법은 실행 계획을 확인하는 것입니다. 
대부분의 관계형 데이터베이스 관리 시스템(RDBMS)은 쿼리의 실행 계획을 보여주는 기능을 제공합니다. 
실행 계획은 데이터베이스가 쿼리를 어떻게 처리할지에 대한 상세 정보를 포함하며, 어떤 인덱스가 사용되는지, 조인이 어떻게 수행되는지, 각 단계에서의 예상 비용과 행 수 등 다양한 정보를 제공합니다.
</details>
<br/>

<details>
<summary>3. 앞 질문들을 통해 인덱스의 중요성을 알 수 있었는데, 그렇다면 JOIN의 성능도 인덱스의 유무의 영향을 받나요?</summary>
JOIN 연산의 성능은 인덱스의 유무에 크게 영향을 받습니다. 
인덱스는 데이터베이스에서 데이터 검색 속도를 향상시키기 위해 사용되는 데이터 구조 중 하나입니다. 
JOIN 연산을 수행할 때, 인덱스가 있으면 데이터베이스는 인덱스를 사용하여 필요한 데이터를 더 빠르게 찾을 수 있습니다. 
특히, JOIN 조건에 사용되는 컬럼에 인덱스가 있을 경우, 데이터베이스는 해당 컬럼을 통해 레코드를 효율적으로 매칭시킬 수 있어 JOIN의 성능이 크게 향상됩니다. 
반면, 인덱스가 없다면, 데이터베이스는 두 테이블의 모든 레코드를 스캔하며 조건에 맞는 레코드를 찾아야 하므로, 처리 시간이 상당히 길어질 수 있습니다. 
따라서, JOIN 연산을 자주 사용하는 컬럼에는 인덱스를 적절히 생성하여 성능을 최적화할 필요가 있습니다.
</details>
<br/>

<details>
<summary>4. 3중 조인 부터는 동작 방식이 약간 바뀝니다. 어떻게 동작하는지, 그리고 그 방식이 성능에 어떠한 영향을 주는지 설명해 주세요.</summary>
3중 조인(또는 그 이상의 다중 조인)의 경우, 데이터베이스는 조인을 수행하는 순서와 방식에 따라 성능에 큰 차이를 보일 수 있습니다. 데이터베이스는 다중 조인을 처리할 때 여러 가지 가능한 조인 순서와 방법을 고려하여, 실행 계획을 세웁니다. 이 과정에서 최적화기(Optimizer)는 다양한 실행 계획 중 예상되는 비용이 가장 낮은 계획을 선택합니다.

3중 조인에서는 두 테이블을 먼저 조인한 후, 결과 테이블을 세 번째 테이블과 조인하는 방식으로 진행될 수 있습니다. 이러한 방식은 중간 결과의 크기와 조인의 순서에 따라 성능에 큰 영향을 미칠 수 있습니다.
예를 들어, 처음 두 테이블의 조인 결과가 매우 크다면, 이 결과를 세 번째 테이블과 조인하는 과정에서 많은 시간과 자원이 소모될 수 있습니다. 반대로, 가장 작은 결과를 먼저 생성할 수 있는 조인 순서를
선택한다면,
전체 조인 과정의 성능을 향상시킬 수 있습니다.

따라서, 다중 조인의 성능을 최적화하기 위해서는 조인 순서, 인덱스의 존재 유무, 조인 조건, 중간 결과의 크기 등 여러 요소를 고려해야 합니다. 데이터베이스의 최적화기는 이러한 요소들을 분석하여 최적의 조인 순서를
결정하지만, 때로는 개발자가 직접 쿼리를 조정하거나
</details>
<br/>

### ✅ 10. B-Tree와 B+Tree에 대해 설명해 주세요.

---

<details>
<summary> B-Tree와 B+Tree 정의</summary>
B-Tree와 B+Tree는 대규모 데이터베이스 및 파일 시스템에서 널리 사용되는 인덱스 구조입니다. 

B-Tree는 균형잡힌 트리 구조로, 모든 리프 노드가 같은 레벨에 있어 데이터 검색, 삽입, 삭제 작업을 효율적으로 수행할 수 있습니다.
B-Tree의 각 노드는 특정 범위의 키를 가지고 있으며, 리프 노드에 데이터를 저장합니다.

반면, B+Tree는 B-Tree의 변형으로, 모든 데이터는 리프 노드에만 저장되고,
내부 노드는 키와 포인터만을 저장합니다. 이 구조는 리프 노드들이 링크드 리스트로 연결되어 있어 범위 검색에 더욱 효율적입니다.
B+Tree에서는 리프 노드를 제외한 노드들이 더 많은 키를 저장할 수 있기 때문에 트리의 높이를 더 낮출 수 있으며, 이는 검색 속도를 향상시킵니다.
</details>
<br/>

<details>
<summary>1. 그렇다면, B+Tree가 B-Tree에 비해 반드시 좋다고 할 수 있을까요? 그렇지 않다면 어떤 단점이 있을까요?</summary>
B+Tree가 B-Tree에 비해 몇 가지 장점을 가지고 있긴 하지만, 반드시 모든 상황에서 더 좋다고 말할 수는 없습니다.
B+Tree는 범위 검색과 순차 접근에 효율적인 반면, B-Tree는 특정 키를 대상으로 한 검색에서 더 빠를 수 있습니다. 
또한, B+Tree의 구조상 리프 노드에만 데이터를 저장하기 때문에, 단일 데이터를 조회할 때 추가적인 디스크 I/O가 발생할 수 있어, 경우에 따라 B-Tree가 더 성능이 좋을 수 있습니다. 
따라서, 요구 사항에 따라 적절한 트리 구조를 선택해야 합니다.
</details>
<br/>

<details>
<summary>2. DB에서 RBT를 사용하지 않고, B-Tree/B+Tree를 사용하는 이유가 있을까요?</summary>
레드-블랙 트리(RBT)는 메모리 내에서 매우 효율적인 검색, 삽입, 삭제 연산을 제공하는 균형 이진 탐색 트리입니다. 
그러나, 대규모 데이터베이스와 파일 시스템에서는 디스크 I/O 비용이 주요 성능 결정 요소입니다. 
B-Tree와 B+Tree는 디스크 기반의 저장 시스템을 고려하여 설계되었습니다. 
이들은 노드당 더 많은 키를 저장할 수 있어 트리의 높이를 줄이고, 결과적으로 디스크 접근 횟수를 감소시킵니다. 
RBT는 이러한 환경에서는 상대적으로 높은 디스크 I/O를 발생시킬 수 있어, 대규모 데이터를 다루는 데는 B-Tree나 B+Tree가 더 적합합니다.
</details>
<br/>

<details>
<summary>3. 오름차순으로 정렬된 인덱스가 있다고 할 때, 내림차순 정렬을 시도할 경우 성능이 어떻게 될까요? B-Tree/B+Tree의 구조를 기반으로 설명해 주세요.</summary>
오름차순으로 정렬된 인덱스를 내림차순으로 정렬할 경우, B-Tree나 B+Tree의 구조상 성능에 큰 차이가 발생하지 않습니다. 
B-Tree와 B+Tree 모두 키-값 쌍을 특정 순서(보통 오름차순)로 저장하며, 검색 알고리즘은 이 순서를 기반으로 합니다.

내림차순 정렬의 경우, B-Tree나 B+Tree는 노드 내에서 키의 순서를 반대로 탐색하거나,
B+Tree의 경우 리프 노드들이 연결된 링크드 리스트를 역방향으로 순회할 수 있습니다.
이런 구조 덕분에 오름차순 정렬 시와 동일한 시간 복잡도로 데이터를 검색할 수 있습니다.

또한, B+Tree의 경우 리프 노드들이 서로 연결되어 있기 때문에, 오름차순이든 내림차순이든 범위 검색이나 순차 접근이 매우 효율적입니다.
따라서, 정렬의 방향에 관계없이 B-Tree나 B+Tree는 효율적으로 작동하여, 성능상 큰 차이를 보이지 않습니다.
</details>
<br/>

### ✅ 11. DB Locking에 대해 설명해 주세요.

---

<details>
<summary> DB Locking 정의</summary>
DB Locking은 데이터베이스 관리 시스템(DBMS)에서 데이터의 일관성과 무결성을 유지하기 위해 동시성 제어를 수행하는 메커니즘입니다. 
여러 사용자나 프로세스가 동시에 같은 데이터에 접근할 때, 잘못된 데이터 읽기, 갱신 손실, 더티 리드와 같은 문제를 방지하기 위해 데이터에 대한 접근을 제한하거나 순서를 정하는 기능을 합니다. 
</details>
<br/>

<details>
<summary>1. Optimistic Lock/Pessimistic Lock에 대해 설명해 주세요.</summary>
Optimistic Lock과 Pessimistic Lock은 DB에서 동시성을 관리하는 두 가지 접근 방식입니다.

- **Pessimistic Lock**: 데이터가 다른 트랜잭션에 의해 변경되거나 수정될 것이라고 '비관적'으로 가정하고, 데이터에 접근하기 전에 락을 걸어 다른 트랜잭션들이 해당 데이터에 접근하지 못하게 하는
  방식입니다.
- 주로 충돌이 자주 발생할 것으로 예상되는 환경에서 사용됩니다.
- 데이터베이스에서는 SELECT FOR UPDATE 구문과 같이 데이터를 조회하면서 동시에 락을 거는 방식으로 구현됩니다.

- **Optimistic Lock**: 데이터 충돌이 드물게 발생할 것이라는 '낙관적'인 가정 하에 구현됩니다.
- 데이터를 읽을 때 락을 걸지 않고, 데이터를 업데이트할 때에만 해당 데이터가 원래 읽었던 시점 이후에 수정되었는지를 확인합니다.
- 수정되었다면 충돌이 감지되고, 트랜잭션은 실패합니다. 버전 번호나 타임스탬프를 사용하여 구현됩니다.

</details>
<br/>

<details>
<summary>2. 물리적인 Lock을 건다면, 만약 이를 수행중인 요청에 문제가 생겨 비정상 종료되면 Lock이 절대 해제되지 않는 문제가 생길 수도 있을 것 같습니다. DB는 이를 위한 해결책이 있나요? 없다면, 우리가 이 문제를 해결할 수 없을까요?</summary>
데이터베이스는 이러한 상황에 대비하여 트랜잭션 관리 기능을 제공합니다. 
트랜잭션은 일련의 데이터베이스 작업들을 논리적으로 묶어서, 모두 성공하거나 모두 실패하도록 보장합니다.
이를 통해 데이터의 일관성과 무결성을 유지합니다.

- **트랜잭션의 자동 롤백**: 요청이 비정상 종료되어 트랜잭션이 완료되지 않으면, 데이터베이스 시스템은 해당 트랜잭션에 의해 수행된 모든 변경 사항을 자동으로 롤백(취소)합니다.
- 이 과정에서 해당 트랜잭션에 의해 설정된 모든 락도 자동으로 해제됩니다.


- **타임아웃과 데드락 감지**: 대부분의 DBMS는 락 타임아웃과 데드락(두 개 이상의 트랜잭션이 서로를 기다리는 상태) 감지 메커니즘을 제공합니다.
- 락이 일반적으로 발생하는 상황은 여러 트랜잭션이 동시에 같은 데이터에 접근하려고 할 때입니다. 이를 효과적으로 관리하기 위해 DBMS는 락 타임아웃과 데드락 감지 기능을 제공합니다. 이러한 기능은 데이터베이스의
  안전한 동시성 제어와 무결성을 유지하는 데 중요한 역할을 합니다.
- 락 타임아웃 설정을 통해, 데이터베이스 관리자는 특정 락이 얼마나 오랫동안 유지될 수 있는지를 제한할 수 있습니다. 이는 무한히 락이 유지되어 시스템이 멈추는 상황을 방지합니다. 만약 설정된 타임아웃 시간을
  초과하면, 해당 락은 자동으로 해제되어 다른 트랜잭션이 진행될 수 있도록 합니다.
- 데드락 감지 기능은 두 개 이상의 트랜잭션이 서로의 완료를 무한히 기다리는 상황, 즉 데드락을 자동으로 감지합니다. 데드락이 감지되면, DBMS는 자동으로 하나 이상의 트랜잭션을 중단시키거나 롤백하여 데드락
  상태를 해결합니다. 이 과정에서 선택된 트랜잭션은 나중에 다시 시도될 수 있습니다.

</details>
<br/>
