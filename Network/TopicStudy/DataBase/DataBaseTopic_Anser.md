### ✅ 1. Key (기본키, 후보키, 슈퍼키 등등...) 에 대해 설명해 주세요.

<details> <summary>기본키, 후보키, 슈퍼키</summary>
기본키(Primary Key): 테이블에서 각 행의 고유함을 보장하는 데 사용되는 열입니다.NULL 값을 가질 수 없으며, 중복 값을 허용하지 않습니다.
<br/>
후보키(Candidate Key): 기본키가 될 수 있는 키로, 레코드를 고유하게 식별할 수 있는 속성 또는 속성 집합입니다.
<br/>
슈퍼키(Super Key): 레코드를 고유하게 식별할 수 있는 속성의 집합을 의미합니다. 후보키와 달리 슈퍼키는 최소성을 만족시키지 않아도 됩니다.
<br/>
</details>

---

<details> 
<summary>1. 기본키는 수정이 가능한가요?</summary>
기본키는 기본적으로 수정이 허용되지 않습니다. 기본키를 변경하면 테이블 간의 관계가 깨질 수 있습니다.
</details>

<details>
<summary>2. 사실 MySQL의 경우, 기본키를 설정하지 않아도 테이블이 만들어집니다. 어떻게 이게 가능한 걸까요?</summary>
    MySQL에서는 기본키를 설정하지 않으면 내부적으로 '인공키'라고 부르는 숨겨진 열을 생성하여 테이블의 각 행을 구별합니다.
    이렇게 하면 사용자가 명시적으로 기본키를 설정하지 않아도 테이블의 레코드를 유일하게 식별할 수 있습니다.
</details>

<details> 
<summary>3. 외래키 값은 NULL이 들어올 수 있나요?</summary>
외래키는 NULL 값을 가질 수 있습니다. 외래키가 NULL인 경우, 그 행은 참조 무결성 제약조건을 만족시킨다고 간주됩니다.
</details>

<details> 
<summary> 4. 어떤 칼럼의 정의에 UNIQUE 키워드가 붙는다고 가정해 봅시다. 이 칼럼을 활용한 쿼리의 성능은 그렇지 않은 것과 비교해서 어떻게 다를까요?</summary>
UNIQUE 키워드가 붙은 칼럼은 중복된 값을 가질 수 없으므로, DBMS는 해당 속성을 활용하여 쿼리의 성능을 향상시킬 수 있습니다.
특히, 해당 칼럼에 대한 SELECT, UPDATE, DELETE 쿼리는 인덱스를 활용하여 빠른 검색 속도를 제공합니다.
</details>
<br/>

### ✅ 2. RDB와 NoSQL의 차이에 대해 설명해 주세요.

<details> <summary>RDB와 NoSQL의 차이</summary>
RDB(Relational Database)는 관계형 데이터베이스로, 데이터를 테이블 형태로 저장하고 SQL을 사용하여 데이터를 관리합니다.
ACID 트랜잭션을 지원하며, 데이터의 무결성을 보장합니다.
<br/>
반면 NoSQL(Not only SQL)은 RDB의 제약을 극복하기 위해 등장한 데이터베이스로, Key-Value, Document, Column, Graph 등 다양한 데이터 모델을 지원합니다. 
대량의 데이터를 빠르게 처리하고 분산 처리를 지원하는 것이 특징입니다.
<br/>
</details>

---

<details> 
<summary>1. NoSQL의 강점과, 약점이 무엇인가요?</summary>
NoSQL의 강점: 대량의 데이터를 빠르게 처리하고, 분산 처리를 지원합니다.
스키마가 없거나 유연하기 때문에 데이터 구조 변경이 용이합니다.

<br/>
NoSQL의 약점: NoSQL 데이터베이스는 종종 RDBMS만큼 세부적인 보안 기능을 제공하지 않습니다. 예를 들어, 열 레벨의 보안이나 롤 기반 접근 제어 등을 제공하지 않을 수 있습니다.
<br/>
NoSQL 데이터베이스는 SQL만큼 강력한 쿼리 언어를 제공하지 않을 수 있어, 복잡한 쿼리를 만드는 데 사용 제한이 있을 수 있습니다.
그리고 ACID 트랜잭션을 완벽하게 지원하지 않을 수 있습니다.
<br/>
</details>

<br/>

<details>
<summary>2. RDB의 어떠한 특징 때문에 NoSQL에 비해 부하가 많이 걸릴 "수" 있을까요? (주의: 무조건 NoSQL이 RDB 보다 빠르다라고 생각하면 큰일 납니다!)</summary>
RDB는 테이블 간의 관계를 유지하면서 ACID 트랜잭션을 보장하기 위해 많은 연산을 수행해야 합니다. 이 때문에 대량의 데이터를 처리하거나 복잡한 쿼리를 실행할 경우 부하가 많이 발생할 수 있습니다.
</details>
<br/>

<details>
<summary>3. NoSQL을 활용한 경험이 있나요? 있다면, 왜 RDB를 선택하지 않고 해당 DB를 선택했는지 설명해 주세요.</summary>
저의 경우, Server-Sent Events(SSE)를 이용한 실시간 알람 서비스를 구현할 때 Redis를 사용한 경험이 있습니다. 이 때문에 RDB 대신 NoSQL 데이터베이스인 Redis를 선택했습니다.

Redis는 메모리 기반의 데이터 저장소로, 빠른 응답 시간과 고성능을 제공하며, 간단한 데이터 구조를 지원합니다. 이러한 특성 때문에 Redis는 실시간 애플리케이션에 특히 유용합니다.

이 프로젝트에서는 여러 서버 간의 메시지 전달을 위해 Redis의 Pub/Sub 기능을 활용했습니다. 이를 통해 서버 간에 메시지를 빠르게 공유하고, 동시에 여러 서버에서 동일한 알람을 받을 수 있었습니다.

RDB를 사용하지 않은 주요 이유는 두 가지입니다.
<br/>
첫째, 실시간 알람 서비스는 빠른 응답 시간이 필요하며, 이는 Redis가 제공하는 높은 성능을 필요로 합니다.
<br/>
둘째, 메시지 큐와 같은 간단한 데이터 구조는 Redis가 잘 지원하므로, 이러한 요구 사항을 충족시키기 위해 Redis를 선택했습니다.
</details>

<br/>

### ✅ 3. 트랜잭션이 무엇이고, ACID 원칙에 대해 설명해 주세요.

<details> 
<summary>트랜잭션</summary>
트랜잭션은 데이터베이스의 상태를 변화시키는 하나의 논리적인 작업 단위를 의미합니다. 그리고 트랜잭션은 ACID 원칙을 따릅니다.
</details>

<br/>

<details> 
<summary>ACID란</summary>
Atomicity(원자성): 트랜잭션은 데이터베이스에 모두 반영되거나, 전혀 반영되지 않아야 함을 의미합니다.
<br/>
Consistency(일관성): 트랜잭션이 성공적으로 완료되면, 데이터베이스는 일관된 상태에 있어야 함을 의미합니다.
<br/>
Isolation(고립성): 각 트랜잭션은 서로 독립적으로 실행되어야 함을 의미합니다.
<br/>
Durability(영속성): 트랜잭션이 성공적으로 완료된 후에는, 그 결과는 영구적으로 반영되어야 함을 의미합니다.
</details>

---

<details> 
<summary> 1. ACID 원칙 중, Durability를 DBMS는 어떻게 보장하나요?</summary>
DBMS는 Durability를 보장하기 위해 트랜잭션이 성공적으로 완료된 후에 변경 사항을 디스크와 같은 영구 저장소에 쓰는 방식을 사용합니다.
<br/>
이 과정에서 로그 기반 복구나 체크포인트 등의 기법이 사용됩니다. 
<br/>
예를 들어, 트랜잭션이 성공적으로 완료된 후에는 해당 트랜잭션에 대한 로그를 디스크에 쓰게 되며, 시스템 장애가 발생한 경우 이 로그를 사용하여 데이터를 복구합니다.
</details>

<br/>

<details> 
<summary>2. 트랜잭션을 사용해 본 경험이 있나요? 어떤 경우에 사용할 수 있나요?</summary>
서비스 레이어에서 트랜잭션을 활용한 경험이 있습니다. 
<br/>
서비스 레이어는 여러 데이터베이스 연산을 조합하여 하나의 비즈니스 로직을 구현하는 곳이기 때문에, 트랜잭션을 사용하여 여러 연산이 모두 성공하거나 모두 실패하도록 보장해야 하는 경우가 있습니다.
<br/>
예를 들어, 저는 "상품 주문"이라는 비즈니스 로직을 구현할 때 "주문 정보 저장", "재고 감소" 등의 연산을 하나의 트랜잭션으로 묶어 처리한 경험이 있습니다.
<br/>
이런 방식으로 트랜잭션을 사용하면, 모든 연산이 성공적으로 완료되지 않으면 롤백을 통해 이전 상태로 돌아가게 되므로, 데이터의 일관성을 유지하면서 안전하게 비즈니스 로직을 처리할 수 있습니다.
</details>

<br/>

<details> 
<summary>3. 읽기에는 트랜잭션을 걸지 않아도 될까요?</summary>
읽기 작업에 트랜잭션을 사용할지 여부는 상황에 따라 다릅니다. 
만약 데이터의 일관성을 보장받아야 하는 경우(즉, 읽는 동안 다른 트랜잭션에 의해 데이터가 변경되는 것을 방지해야 하는 경우)에는 읽기 작업에도 트랜잭션을 사용해야 합니다.
</details>
<br/>

### ✅ 4. 트랜잭션 격리 레벨에 대해 설명해 주세요.

<details>
<summary>트랜잭션 격리 레벨</summary>
트랜잭션 격리 레벨은 동시에 여러 트랜잭션이 실행될 때 트랜잭션들이 서로 얼마나 영향을 미치는지를 결정하는 것입니다.
<br/>
SQL 표준에서는 다음과 같이 4개의 격리 레벨이 정의되어 있습니다
<br/>
1. READ UNCOMMITTED 
<br/>
2. READ COMMITTED 
<br/>
3. REPEATABLE READ 
<br/>
4. SERIALIZABLE
</details>

---

<details> <summary>1. 모든 DBMS가 4개의 레벨을 모두 구현하고 있나요? 그렇지 않다면 그 이유는 무엇일까요?</summary>
모든 DBMS가 4개의 트랜잭션 격리 레벨을 모두 구현하고 있지는 않습니다.
<br/>
이는 각 DBMS의 내부 구현과 성능, 사용 사례 등에 따라 다릅니다.
<br/>
예를 들어, MySQL의 InnoDB 스토리지 엔진은 READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ, SERIALIZABLE의 4개의 격리 레벨을 제공하지만, 기본 격리 레벨은 REPEATABLE READ입니다.
</details>

<br/>

<details> 
<summary>2. 만약 MySQL을 사용하고 있다면, (InnoDB 기준) Undo 영역과 Redo 영역에 대해 설명해 주세요.</summary>
MySQL의 InnoDB 스토리지 엔진은 트랜잭션 처리와 복구를 위해 Undo 영역과 Redo 영역을 사용합니다.
<br/>
Undo 영역: 이 영역은 트랜잭션이 롤백되어야 할 때 이전 상태로 되돌릴 수 있도록 데이터 변경 내역을 저장합니다. 또한, 다른 트랜잭션에서 변경된 데이터를 고립된 상태로 볼 수 있게 하는 데에도 사용됩니다.
<br/>
Redo 영역: 이 영역은 시스템 장애가 발생했을 때 데이터를 복구하는 데 사용됩니다. 트랜잭션이 커밋되었을 때, 변경 내역은 디스크에 바로 기록되지 않고 Redo 로그 버퍼에 먼저 기록되며, 이후에 디스크에 기록됩니다
<br/>
</details>

<br/>

<details> 
<summary>3. 그런데, 스토리지 엔진이 정확히 무엇을 하는 건가요?</summary>
스토리지 엔진은 DBMS에서 데이터의 저장, 검색, 관리 방식을 결정하는 핵심 컴포넌트입니다.
이는 테이블의 구조, 인덱싱, 트랜잭션 처리, 데이터 복구 등을 담당합니다.
따라서 사용하는 스토리지 엔진에 따라 DBMS의 성능, 복구 기능, 트랜잭션 처리 방식 등이 달라집니다.
</details>
<br/>

### ✅ 5. 인덱스가 무엇이고, 언제 사용하는지 설명해 주세요.

<details>
<summary>인덱스의 정의와 사용 예시</summary>
인덱스는 데이터베이스에서 데이터 검색 속도를 높이기 위한 자료구조이다.
인덱스는 마치 책의 색인과 같이 특정한 값을 가진 데이터의 위치 정보를 가지고 있습니다.
이를 통해 데이터 검색 시 전체 데이터를 검색하는 풀 스캔이 아닌, 인덱스를 통해 빠르게 데이터의 위치를 찾아 접근할 수 있습니다.
</details>
<br/>

---

<details> 
<summary>1. 일반적으로 인덱스는 수정이 잦은 테이블에선 사용하지 않기를 권합니다. 왜 그럴까요?</summary>
인덱스는 데이터베이스에서 데이터 검색 속도를 높이는 역할을 합니다. 
그러나 데이터가 변경될 때마다 인덱스 또한 함께 업데이트되어야 합니다.
따라서, 데이터의 수정이 빈번하게 일어나는 테이블에서는 인덱스를 사용하면 인덱스의 잦은 업데이트로 인한 오버헤드가 발생하여 성능 저하가 일어날 수 있습니다.
</details>
<br/>

<details> 
<summary>2. 앞 꼬리질문에 대해, 그렇다면 인덱스에서 사용하지 않겠다고 선택한 값은 위 정책을 그대로 따라가나요?</summary>
인덱스에서 사용하지 않겠다고 선택한 값은 위 정책을 따르기도 하지만, 데이터의 종류, 사용 빈도 등에 따라 다르게 적용될 수 있습니다. 
예를 들어, 검색 빈도가 낮거나, 데이터의 분포가 균일하지 않는 경우 인덱스의 효율이 떨어질 수 있으므로 해당 경우, 인덱스에서 제외될 수 있습니다.
</details> 
<br/>

<details> 
<summary>3. ORDER BY/GROUP BY 연산의 동작 과정을 인덱스의 존재여부와 연관지어서 설명해 주세요.</summary>
인덱스가 존재하면 ORDER BY나 GROUP BY 연산은 인덱스를 이용하여 훨씬 빠르게 동작할 수 있습니다.
인덱스는 이미 정렬된 상태로 데이터의 위치 정보를 가지고 있기 때문에 인덱스를 스캔하면서 바로 정렬 또는 그룹화를 수행할 수 있습니다.
반면 인덱스가 없으면 전체 데이터를 스캔하고 정렬 또는 그룹화를 수행해야 하므로 처리 시간이 더 많이 소요됩니다.
</details>
<br/>

<details>
<summary>4.기본키는 인덱스라고 할 수 있을까요? 그렇지 않다면, 인덱스와 기본키는 어떤 차이가 있나요?</summary>
기본키는 테이블의 각 행을 유일하게 식별하는 역할을 하며, 자동으로 인덱스가 생성됩니다.
따라서 기본키는 인덱스의 일종이라고 볼 수 있습니다. 
하지만 기본키는 테이블에서 단 하나만 존재할 수 있고, NULL 값을 허용하지 않는 등 인덱스와는 차이점이 있습니다. 
인덱스는 중복 값을 허용하며, 여러 개를 설정할 수 있습니다.
</details>
<br/>

<details>
<summary>5.그렇다면 외래키는요?</summary>
외래키 또한 인덱스로 사용될 수 있습니다. 외래키는 다른 테이블의 기본키를 참조하는 키로, 참조 무결성을 보장하는데 사용됩니다.
외래키에 인덱스를 사용하면 JOIN 연산 등에서 성능을 향상시키는 데 도움이 됩니다.
</details>
<br/>

<details>
<summary>6.인덱스가 데이터의 물리적 저장에도 영향을 미치나요? 그렇지 않다면, 데이터는 어떤 순서로 물리적으로 저장되나요?</summary>
인덱스는 데이터의 물리적인 저장 순서에 영향을 주지 않습니다. 인덱스는 데이터의 위치 정보를 가지고 있지만, 이는 데이터가 실제로 저장된 디스크의 위치를 나타내는 것이지, 데이터의 물리적인 저장 순서를 결정하는 것은 아닙니다. 
데이터의 물리적 저장 순서는 데이터베이스 관리 시스템(DBMS)의 파일 시스템에 따라 결정됩니다.
</details>
<br/>

<details>
<summary>7.우리가 아는 RDB가 아닌 NoSQL (ex. Redis, MongoDB 등)는 인덱스를 갖고 있나요? 만약 있다면, RDB의 인덱스와는 어떤 차이가 있을까요?</summary>
NoSQL 데이터베이스 또한 인덱스를 가질 수 있습니다. 하지만 RDB와는 달리 NoSQL의 인덱스는 스키마가 고정되지 않아, 동적으로 변경되는 데이터에 대해 유연하게 인덱스를 적용할 수 있습니다.
또한, NoSQL 데이터베이스는 대량의 데이터를 처리하는 데 특화되어 있기 때문에, 이에 맞는 다양한 인덱스 구조를 제공합니다.
</details>
<br/>

<details>
<summary>8.(A, B) 와 같은 방식으로 인덱스를 설정한 테이블에서, A 조건 없이 B 조건만 사용하여 쿼리를 요청했습니다. 해당 쿼리는 인덱스를 탈까요?</summary>
(A, B)와 같은 복합 인덱스에서 A 조건 없이 B 조건만 사용하여 쿼리를 요청하면, 해당 쿼리는 인덱스를 사용하지 않습니다. 복합 인덱스는 왼쪽부터 읽혀지기 때문에, A 조건이 없으면 B 조건에 대한 인덱스를 찾을 수 없습니다.
</details>
<br/>

### ✅ 6. RDBMS, NoSQL에서의 클러스터링/레플리케이션 방식에 대해 설명해 주세요.

<details>
<summary>클러스터링/레플리케이션의 정의</summary>
클러스터링: 클러스터링은 여러 서버(노드)가 하나의 데이터베이스를 공유하도록 구성하는 것을 의미합니다. 
이를 통해 데이터베이스의 성능을 향상시키고, 가용성을 높일 수 있습니다.
RDBMS에서는 클러스터링을 위해 종종 샤딩을 사용하여 데이터를 여러 서버에 분산합니다.
NoSQL에서는 일반적으로 분산 처리를 위해 클러스터링을 사용합니다.
<br/>
레플리케이션: 레플리케이션은 데이터를 여러 노드에 복제하는 것을 의미합니다. 
이를 통해 데이터의 가용성을 높이고, 시스템의 부하를 분산할 수 있습니다. RDBMS에서는 주로 마스터-슬레이브 레플리케이션을 사용합니다.
마스터 노드에서 발생하는 모든 변경사항이 슬레이브 노드에 복제됩니다. NoSQL에서는 종종 다중 마스터 레플리케이션을 사용합니다.
모든 노드가 동일한 권한을 가지며, 어느 노드에서든 변경사항을 적용할 수 있습니다.
</details>

---

<details>
<summary>1.이러한 분산 환경에선, 트랜잭션을 어떻게 관리할 수 있을까요?</summary>
분산 트랜잭션은 여러 노드에 걸쳐 수행되는 트랜잭션을 의미하며, 이를 위한 대표적인 프로토콜로는 2단계 커밋(2PC, Two-Phase Commit)과 3단계 커밋(3PC, Three-Phase Commit)이 있습니다.
<br/>
2PC는 모든 참여 노드에게 커밋 의사를 묻는 투표 단계와 실제 커밋을 수행하는 단계로 이루어집니다. 하지만 이 방식은 한 노드가 실패할 경우 전체 시스템이 블로킹되는 문제가 있습니다.
<br/>
3PC는 이 문제를 해결하기 위해 타임아웃과 같은 메커니즘을 도입해, 노드의 실패에도 블로킹 없이 트랜잭션을 진행할 수 있도록 합니다.
<br/>
그러나 이런 방식도 네트워크 지연, 노드 장애 등의 문제로 인해 완전한 일관성을 보장하기 어렵습니다. 따라서 분산 환경에서는 종종 '최종적 일관성'이라는 느슨한 일관성 모델을 사용하기도 합니다.
</details>
<br/>

<details>
<summary>2.마스터, 슬레이브 데이터 동기화 전 까지의 데이터 정합성을 지키는 방법은 무엇이 있을까요?</summary>
마스터-슬레이브 구조에서는 보통 비동기적인 방식으로 레플리케이션이 이루어집니다. 
이 경우 마스터와 슬레이브 사이의 데이터 불일치가 발생할 수 있습니다. 이러한 문제를 해결하기 위한 방법으로는 다음과 같은 방법이 있습니다.
<br/>
1.세미-동기 레플리케이션: 마스터는 트랜잭션을 커밋하기 전에 적어도 하나의 슬레이브에 데이터가 복제되었음을 확인합니다. 이 방식은 데이터 불일치 확률을 줄일 수 있지만, 마스터의 성능에 영향을 줄 수 있습니다.
<br/>
2.레드 로그(Write-Ahead Logging): 마스터는 모든 변경을 먼저 로그에 기록하고, 이 로그를 슬레이브에 전송합니다. 슬레이브는 로그를 순차적으로 재생하여 데이터를 동기화합니다.
<br/>
3.마스터에서 슬레이브로의 변경 전파 지연: 네트워크 지연이나 슬레이브의 처리 지연 등으로 인해 변경이 즉시 전파되지 않을 수 있습니다. 이 경우 주기적인 스냅샷, 로그 기반의 복구 등을 활용해 데이터 정합성을 유지할 수 있습니다.
</details>
<br/>

<details>
<summary>3.다중 트랜잭션 상황에서의 Deadlock 상황과, 이를 해결하기 위한 방법에 대해 설명해 주세요.</summary>
Deadlock은 두 개 이상의 트랜잭션이 각각 다른 트랜잭션이 소유한 자원을 기다리면서 무한 대기 상태에 빠지는 현상을 말합니다. 이를 해결하기 위한 방법으로는 다음과 같은 방법들이 있습니다
<br/>
1.자원 할당 그래프를 사용하여 사이클을 감지하고, 이를 통해 교착 상태를 예방하거나 회피합니다.
2.시스템이 교착 상태를 주기적으로 검사하고, 발견될 경우 트랜잭션 중 하나를 선택하여 중단(롤백)시키는 방법입니다.
3.트랜잭션에 우선순위를 부여하여, 낮은 우선순위의 트랜잭션을 중단시키는 방법입니다.
4.트랜잭션에 시간 제한을 설정하여, 제한 시간 내에 완료되지 않는 트랜잭션을 중단시키는 방법입니다.
</details>
<br/>

<details>
<summary>4.샤딩 방식은 무엇인가요? 만약 본인이 DB를 분산해서 관리해야 한다면, 레플리케이션 방식과 샤딩 방식 중 어떤 것을 사용할 것 같나요?</summary>
샤딩은 데이터베이스를 여러 파티션으로 나누는 방법입니다. 각 파티션은 독립적인 데이터베이스로 작동하며, 데이터의 일부를 저장하고 관리합니다. 
샤딩은 대량의 데이터를 다루고, 성능과 가용성을 향상시키는 데 효과적입니다.
<br/>
레플리케이션과 샤딩은 각각 다른 문제를 해결하기 위한 방법입니다.
레플리케이션은 데이터의 복사본을 여러 노드에 분산시킴으로써 데이터의 가용성을 높이고, 시스템의 부하를 분산시키는 데 사용됩니다. 
반면, 샤딩은 데이터를 여러 노드에 분할하여 저장함으로써, 대량의 데이터를 관리하고, 쿼리 성능을 향상시키는 데 사용됩니다.
<br/>
따라서 DB를 분산해서 관리한다면, 어떤 방식을 사용할지는 시스템의 요구 사항과 목표에 따라 달라집니다.
데이터의 가용성이 중요한 경우에는 레플리케이션을, 대량의 데이터를 빠르게 처리해야 하는 경우에는 샤딩을 고려할 수 있습니다.
</details>
<br/>

### ✅ 7. 정규화가 무엇인가요?

<details>
<summary> 정규화의 정의</summary>
데이터베이스의 정규화는 데이터의 중복을 최소화하고, 데이터베이스 구조를 효율적으로 만들기 위한 과정입니다. 이는 데이터의 무결성과 일관성을 향상시킵니다.
<br/>
정규화의 목적은 데이터베이스에서 중복된 데이터를 제거하고, 데이터의 구조를 향상시키는 것입니다. 
데이터의 중복을 제거함으로써 데이터의 갱신, 삽입, 삭제 시 발생할 수 있는 이상 현상을 방지할 수 있습니다.
</details>

---

<details>
<summary>1.정규화를 하지 않을 경우, 발생할 수 있는 이상현상에 대해 설명해 주세요.</summary>
정규화를 하지 않을 경우, 다음과 같은 이상 현상(Anomalies)이 발생할 수 있습니다.
<br/>
1. 삽입 이상 (Insertion Anomaly): 불필요한 데이터까지 입력해야 하는 문제입니다. 예를 들어, 학생과 과목에 대한 정보를 같이 저장하는 테이블에서 새 과목을 추가하려면, 학생 정보 없이는 과목 정보만을 추가할 수 없습니다.
<br/>
2. 갱신 이상 (Update Anomaly): 일부만 변경되어 데이터 불일치가 발생하는 문제입니다. 예를 들어, 동일한 학생 정보가 여러 행에 걸쳐 저장되어 있는데, 이 중 일부만 갱신되면 정보의 일관성이 깨집니다.
<br/>
3. 삭제 이상 (Deletion Anomaly): 의도하지 않은 정보 손실이 발생하는 문제입니다. 예를 들어, 학생이 수강하는 마지막 과목을 삭제하면, 해당 학생에 대한 정보까지 같이 삭제될 수 있습니다.
</details>
<br/>

<details>
<summary>2.각 정규화에 대해, 그 정규화가 진행되기 전/후의 테이블의 변화에 대해 설명해 주세요.</summary>
제1정규화: 각 컬럼의 값이 원자적(Atomic)해야 합니다. 즉, 하나의 컬럼에는 하나의 값만 있어야 하며, 여러 값을 가지려면 별도의 테이블로 분리해야 합니다.
<br/>
제2정규화: 제1정규화를 만족하며, 기본키가 아닌 모든 컬럼이 기본키에 완전 함수 종속해야 합니다. 즉, 기본키의 일부에 종속된 컬럼이 있으면 별도의 테이블로 분리해야 합니다.
<br/>
제3정규화: 제2정규화를 만족하며, 기본키가 아닌 모든 컬럼이 기본키에 대해 이행적 함수 종속이 없어야 합니다. 즉, 기본키가 아닌 컬럼 간에 종속성이 있으면 별도의 테이블로 분리해야 합니다.
<br/>
BCNF(Boyce-Codd Normal Form): 제3정규화를 만족하며, 모든 결정자가 후보키(Candidate Key) 부분 집합이어야 합니다. 즉, 후보키가 아닌 결정자가 있으면 별도의 테이블로 분리해야 합니다.
<br/>
</details>
<br/>

<details>
<summary>3.정규화가 무조건 좋은가요? 그렇지 않다면, 어떤 상황에서 역정규화를 하는게 좋은지 설명해 주세요.</summary>
정규화는 데이터의 중복을 제거하고, 데이터의 일관성을 유지하는데 효과적입니다.
하지만, 너무 많은 정규화로 인해 테이블이 과도하게 분리되면, JOIN 연산이 빈번하게 발생하여 성능이 저하될 수 있습니다.
또한, 데이터를 읽는 쿼리가 주로 발생하고, 데이터 갱신이 잦지 않은 경우에는 데이터의 중복이 일부 발생하더라도, 데이터의 조회 성능을 향상시키기 위해 역정규화를 고려할 수 있습니다.
<br/>
역정규화는 정규화된 테이블을 재조정하여 성능을 향상시키거나, 데이터 관리를 단순화하는 과정입니다. 
이는 테이블의 조인을 줄이거나, 계산된 값을 미리 저장하는 등의 방법으로 수행됩니다. 
역정규화는 신중하게 수행되어야 하며, 데이터의 일관성 유지 등에 대한 추가적인 관리가 필요합니다.
</details>
<br/>
